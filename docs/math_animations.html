<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Math Animations</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        h1 {
            text-align: center;
            color: #333;
        }
        .container {
            display: flex;
            flex-direction: column;
            gap: 40px;
        }
        .animation-card {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .animation-card h2 {
            color: #0066cc;
            margin-top: 0;
        }
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 15px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
        }
        label {
            font-weight: bold;
            margin-bottom: 5px;
        }
        .svg-container {
            background-color: #f9f9f9;
            border-radius: 4px;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <h1>Interactive Math Animations</h1>
    
    <div class="container">
        <div class="animation-card">
            <h2>Sine Wave Animation</h2>
            <div class="controls">
                <div class="control-group">
                    <label for="sine-frequency">Frequency</label>
                    <input type="range" id="sine-frequency" min="0.5" max="5" step="0.1" value="1">
                </div>
                <div class="control-group">
                    <label for="sine-amplitude">Amplitude</label>
                    <input type="range" id="sine-amplitude" min="10" max="100" step="5" value="50">
                </div>
                <div class="control-group">
                    <label for="sine-speed">Speed</label>
                    <input type="range" id="sine-speed" min="0.1" max="2" step="0.1" value="0.5">
                </div>
            </div>
            <div class="svg-container" id="sine-wave-container"></div>
        </div>
        
        <div class="animation-card">
            <h2>Lissajous Curve Animation</h2>
            <div class="controls">
                <div class="control-group">
                    <label for="lissajous-a">X Frequency (a)</label>
                    <input type="range" id="lissajous-a" min="1" max="10" step="1" value="3">
                </div>
                <div class="control-group">
                    <label for="lissajous-b">Y Frequency (b)</label>
                    <input type="range" id="lissajous-b" min="1" max="10" step="1" value="2">
                </div>
                <div class="control-group">
                    <label for="lissajous-delta">Phase Difference (δ)</label>
                    <input type="range" id="lissajous-delta" min="0" max="6.28" step="0.1" value="1.57">
                </div>
                <div class="control-group">
                    <label for="lissajous-speed">Speed</label>
                    <input type="range" id="lissajous-speed" min="0.1" max="2" step="0.1" value="0.5">
                </div>
            </div>
            <div class="svg-container" id="lissajous-container"></div>
        </div>

        <div class="animation-card">
            <h2>Fourier Series Animation</h2>
            <div class="controls">
                <div class="control-group">
                    <label for="fourier-terms">Number of Terms</label>
                    <input type="range" id="fourier-terms" min="1" max="20" step="1" value="5">
                    <span id="fourier-terms-value">5</span>
                </div>
                <div class="control-group">
                    <label for="fourier-speed">Speed</label>
                    <input type="range" id="fourier-speed" min="0.1" max="2" step="0.1" value="0.5">
                </div>
                <div class="control-group">
                    <label for="fourier-function">Function</label>
                    <select id="fourier-function">
                        <option value="square">Square Wave</option>
                        <option value="sawtooth">Sawtooth Wave</option>
                        <option value="triangle">Triangle Wave</option>
                    </select>
                </div>
            </div>
            <div class="svg-container" id="fourier-container"></div>
        </div>
    </div>

    <script>
    // Sine Wave Animation
    (function() {
        // Set up dimensions and margins
        const margin = { top: 20, right: 20, bottom: 20, left: 40 };
        const width = 800 - margin.left - margin.right;
        const height = 300 - margin.top - margin.bottom;
        
        // Create SVG container
        const svg = d3.select("#sine-wave-container")
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);
        
        // Set up scales
        const xScale = d3.scaleLinear()
            .domain([0, 2 * Math.PI])
            .range([0, width]);
        
        const yScale = d3.scaleLinear()
            .domain([-1, 1])
            .range([height, 0]);
        
        // Add axes
        const xAxis = d3.axisBottom(xScale)
            .tickValues(d3.range(0, 2.1 * Math.PI, Math.PI / 2))
            .tickFormat(d => {
                if (d === 0) return "0";
                if (d === Math.PI / 2) return "π/2";
                if (d === Math.PI) return "π";
                if (d === 3 * Math.PI / 2) return "3π/2";
                if (d === 2 * Math.PI) return "2π";
                return "";
            });
        
        const yAxis = d3.axisLeft(yScale);
        
        svg.append("g")
            .attr("class", "x-axis")
            .attr("transform", `translate(0,${height/2})`)
            .call(xAxis);
        
        svg.append("g")
            .attr("class", "y-axis")
            .call(yAxis);
        
        // Add the center line
        svg.append("line")
            .attr("x1", 0)
            .attr("y1", height/2)
            .attr("x2", width)
            .attr("y2", height/2)
            .attr("stroke", "#ddd")
            .attr("stroke-width", 1);
        
        // Create a line generator for the sine wave
        const lineGenerator = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y))
            .curve(d3.curveCardinal);
        
        // Create the path element for the sine wave
        const path = svg.append("path")
            .attr("fill", "none")
            .attr("stroke", "#0066cc")
            .attr("stroke-width", 2);
        
        // Create animated points along the wave
        const point = svg.append("circle")
            .attr("r", 6)
            .attr("fill", "red");
        
        // Parameters for the wave
        let frequency = 1;
        let amplitude = 50;
        let speed = 0.5;
        let phase = 0;
        
        // Get the control elements
        const freqSlider = document.getElementById("sine-frequency");
        const ampSlider = document.getElementById("sine-amplitude");
        const speedSlider = document.getElementById("sine-speed");
        
        // Add event listeners to the controls
        freqSlider.addEventListener("input", () => {
            frequency = parseFloat(freqSlider.value);
        });
        
        ampSlider.addEventListener("input", () => {
            amplitude = parseFloat(ampSlider.value);
            // Update y scale based on amplitude
            const normalizedAmp = amplitude / 100;
            yScale.domain([-normalizedAmp, normalizedAmp]);
            svg.select(".y-axis").call(yAxis);
        });
        
        speedSlider.addEventListener("input", () => {
            speed = parseFloat(speedSlider.value);
        });
        
        // Animation function
        function updateSineWave() {
            phase += 0.02 * speed;
            if (phase > 2 * Math.PI) {
                phase -= 2 * Math.PI;
            }
            
            // Generate data points for the sine wave
            const normalizedAmp = amplitude / 100;
            const points = [];
            const numPoints = 100;
            
            for (let i = 0; i <= numPoints; i++) {
                const x = (i / numPoints) * 2 * Math.PI;
                const y = normalizedAmp * Math.sin(frequency * x + phase);
                points.push({ x, y });
            }
            
            // Update the path
            path.attr("d", lineGenerator(points));
            
            // Update the animated point
            const pointX = xScale(phase % (2 * Math.PI));
            const pointY = yScale(normalizedAmp * Math.sin(frequency * (phase % (2 * Math.PI))));
            point.attr("cx", pointX).attr("cy", pointY);
            
            // Continue the animation
            requestAnimationFrame(updateSineWave);
        }
        
        // Start the animation
        updateSineWave();
    })();

    // Lissajous Curve Animation
    (function() {
        // Set up dimensions and margins
        const margin = { top: 20, right: 20, bottom: 20, left: 20 };
        const width = 800 - margin.left - margin.right;
        const height = 400 - margin.top - margin.bottom;
        
        // Create SVG container
        const svg = d3.select("#lissajous-container")
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", `translate(${width/2 + margin.left},${height/2 + margin.top})`);
        
        // Create a background circle to show the bounds
        svg.append("circle")
            .attr("cx", 0)
            .attr("cy", 0)
            .attr("r", Math.min(width, height) / 2 - 20)
            .attr("fill", "none")
            .attr("stroke", "#ddd")
            .attr("stroke-dasharray", "4,4");
        
        // Add axes
        svg.append("line")
            .attr("x1", -width/2)
            .attr("y1", 0)
            .attr("x2", width/2)
            .attr("y2", 0)
            .attr("stroke", "#ddd");
        
        svg.append("line")
            .attr("x1", 0)
            .attr("y1", -height/2)
            .attr("x2", 0)
            .attr("y2", height/2)
            .attr("stroke", "#ddd");
        
        // Create a path for the Lissajous curve
        const pathHistory = svg.append("path")
            .attr("fill", "none")
            .attr("stroke", "#0066cc")
            .attr("stroke-width", 1.5);
        
        // Create the moving point
        const point = svg.append("circle")
            .attr("r", 6)
            .attr("fill", "red");
        
        // Parameters for the Lissajous curve
        let a = 3; // X frequency
        let b = 2; // Y frequency
        let delta = Math.PI/2; // Phase difference
        let speed = 0.5;
        let t = 0; // Parameter
        
        // History of points for the trail
        const historyPoints = [];
        const historySize = 500;
        
        // Get the control elements
        const aSlider = document.getElementById("lissajous-a");
        const bSlider = document.getElementById("lissajous-b");
        const deltaSlider = document.getElementById("lissajous-delta");
        const speedSlider = document.getElementById("lissajous-speed");
        
        // Add event listeners to the controls
        aSlider.addEventListener("input", () => {
            a = parseInt(aSlider.value);
            historyPoints.length = 0; // Clear history when parameters change
        });
        
        bSlider.addEventListener("input", () => {
            b = parseInt(bSlider.value);
            historyPoints.length = 0;
        });
        
        deltaSlider.addEventListener("input", () => {
            delta = parseFloat(deltaSlider.value);
            historyPoints.length = 0;
        });
        
        speedSlider.addEventListener("input", () => {
            speed = parseFloat(speedSlider.value);
        });
        
        // Line generator for the path
        const lineGenerator = d3.line()
            .x(d => d.x)
            .y(d => d.y);
        
        // Animation function
        function updateLissajous() {
            // Increment the parameter
            t += 0.01 * speed;
            
            // Calculate the radius based on the smaller dimension
            const radius = Math.min(width, height) / 2 - 30;
            
            // Calculate the current point on the Lissajous curve
            const x = radius * Math.sin(a * t + delta);
            const y = radius * Math.sin(b * t);
            
            // Add the point to history
            historyPoints.push({ x, y });
            
            // Limit the history size
            if (historyPoints.length > historySize) {
                historyPoints.shift();
            }
            
            // Update the path
            pathHistory.attr("d", lineGenerator(historyPoints));
            
            // Update the point
            point.attr("cx", x).attr("cy", y);
            
            // Continue the animation
            requestAnimationFrame(updateLissajous);
        }
        
        // Start the animation
        updateLissajous();
    })();

    // Fourier Series Animation
    (function() {
        // Set up dimensions and margins
        const margin = { top: 20, right: 20, bottom: 20, left: 40 };
        const width = 800 - margin.left - margin.right;
        const height = 300 - margin.top - margin.bottom;
        
        // Create SVG container
        const svg = d3.select("#fourier-container")
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);
        
        // Set up scales
        const xScale = d3.scaleLinear()
            .domain([0, 2 * Math.PI])
            .range([0, width]);
        
        const yScale = d3.scaleLinear()
            .domain([-1.5, 1.5])
            .range([height, 0]);
        
        // Add axes
        const xAxis = d3.axisBottom(xScale)
            .tickValues(d3.range(0, 2.1 * Math.PI, Math.PI / 2))
            .tickFormat(d => {
                if (d === 0) return "0";
                if (d === Math.PI / 2) return "π/2";
                if (d === Math.PI) return "π";
                if (d === 3 * Math.PI / 2) return "3π/2";
                if (d === 2 * Math.PI) return "2π";
                return "";
            });
        
        const yAxis = d3.axisLeft(yScale);
        
        svg.append("g")
            .attr("class", "x-axis")
            .attr("transform", `translate(0,${height/2})`)
            .call(xAxis);
        
        svg.append("g")
            .attr("class", "y-axis")
            .call(yAxis);
        
        // Add the center line
        svg.append("line")
            .attr("x1", 0)
            .attr("y1", height/2)
            .attr("x2", width)
            .attr("y2", height/2)
            .attr("stroke", "#ddd")
            .attr("stroke-width", 1);
        
        // Create a line generator for the approximation
        const lineGenerator = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y))
            .curve(d3.curveMonotoneX);
        
        // Create the path element for the target function (ideal)
        const targetPath = svg.append("path")
            .attr("fill", "none")
            .attr("stroke", "#ddd")
            .attr("stroke-width", 1)
            .attr("stroke-dasharray", "5,5");
        
        // Create the path element for the approximation
        const approxPath = svg.append("path")
            .attr("fill", "none")
            .attr("stroke", "#0066cc")
            .attr("stroke-width", 2);
        
        // Parameters
        let numTerms = 5;
        let speed = 0.5;
        let phase = 0;
        let functionType = "square";
        
        // Get the control elements
        const termsSlider = document.getElementById("fourier-terms");
        const termsValue = document.getElementById("fourier-terms-value");
        const speedSlider = document.getElementById("fourier-speed");
        const functionSelect = document.getElementById("fourier-function");
        
        // Add event listeners to the controls
        termsSlider.addEventListener("input", () => {
            numTerms = parseInt(termsSlider.value);
            termsValue.textContent = numTerms;
        });
        
        speedSlider.addEventListener("input", () => {
            speed = parseFloat(speedSlider.value);
        });
        
        functionSelect.addEventListener("change", () => {
            functionType = functionSelect.value;
        });
        
        // Function to calculate the target function value
        function targetFunction(x) {
            switch (functionType) {
                case "square":
                    return x % (2 * Math.PI) < Math.PI ? 1 : -1;
                case "sawtooth":
                    return 1 - (x % (2 * Math.PI)) / Math.PI;
                case "triangle":
                    const mod = x % (2 * Math.PI);
                    return mod < Math.PI 
                        ? -1 + 2 * mod / Math.PI 
                        : 3 - 2 * mod / Math.PI;
                default:
                    return 0;
            }
        }
        
        // Function to calculate the Fourier series approximation for square wave
        function squareWaveApproximation(x, n) {
            let sum = 0;
            for (let i = 1; i <= n; i += 2) {
                sum += (4 / (i * Math.PI)) * Math.sin(i * (x - phase));
            }
            return sum;
        }
        
        // Function to calculate the Fourier series approximation for sawtooth wave
        function sawtoothWaveApproximation(x, n) {
            let sum = 0.5;
            for (let i = 1; i <= n; i++) {
                sum -= (1 / (i * Math.PI)) * Math.sin(i * (x - phase));
            }
            return sum;
        }
        
        // Function to calculate the Fourier series approximation for triangle wave
        function triangleWaveApproximation(x, n) {
            let sum = 0;
            for (let i = 1; i <= n; i += 2) {
                const term = (8 / (Math.PI * Math.PI * i * i)) * Math.cos(i * (x - phase));
                sum += i % 4 === 1 ? term : -term;
            }
            return sum;
        }
        
        // Function to get the appropriate approximation function
        function getApproximation(x, n) {
            switch (functionType) {
                case "square":
                    return squareWaveApproximation(x, n);
                case "sawtooth":
                    return sawtoothWaveApproximation(x, n);
                case "triangle":
                    return triangleWaveApproximation(x, n);
                default:
                    return 0;
            }
        }
        
        // Animation function
        function updateFourierSeries() {
            phase += 0.02 * speed;
            if (phase > 2 * Math.PI) {
                phase -= 2 * Math.PI;
            }
            
            // Generate data points for the target function
            const targetPoints = [];
            const approxPoints = [];
            const numPoints = 200;
            
            for (let i = 0; i <= numPoints; i++) {
                const x = (i / numPoints) * 2 * Math.PI;
                const targetY = targetFunction(x + phase);
                const approxY = getApproximation(x + phase, numTerms);
                
                targetPoints.push({ x, y: targetY });
                approxPoints.push({ x, y: approxY });
            }
            
            // Update the paths
            targetPath.attr("d", lineGenerator(targetPoints));
            approxPath.attr("d", lineGenerator(approxPoints));
            
            // Continue the animation
            requestAnimationFrame(updateFourierSeries);
        }
        
        // Start the animation
        updateFourierSeries();
    })();
    </script>
</body>
</html>